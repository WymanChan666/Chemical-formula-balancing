# chemical_equation_balancer.py
import numpy as np
from collections import defaultdict
import re

class ChemicalEquationBalancer:
    def __init__(self):
        self.elements = set()
    
    def parse_molecule(self, molecule):
        """è§£æå–®å€‹åˆ†å­ï¼Œè¿”å›å…ƒç´ è¨ˆæ•¸å­—å…¸"""
        elements = defaultdict(int)
        
        # ä½¿ç”¨æ­£å‰‡è¡¨é”å¼åŒ¹é…å…ƒç´ å’Œæ•¸é‡
        pattern = r'([A-Z][a-z]*)(\d*)'
        matches = re.findall(pattern, molecule)
        
        for element, count in matches:
            count = int(count) if count else 1
            elements[element] += count
            self.elements.add(element)
        
        return elements
    
    def parse_side(self, side):
        """è§£ææ–¹ç¨‹å¼çš„ä¸€é‚Šï¼ˆåæ‡‰ç‰©æˆ–ç”Ÿæˆç‰©ï¼‰"""
        molecules = side.split('+')
        side_elements = defaultdict(int)
        
        for mol in molecules:
            mol = mol.strip()
            elements = self.parse_molecule(mol)
            # æš«æ™‚å‡è¨­ä¿‚æ•¸ç‚º1ï¼Œå¾Œé¢æœƒç”¨çŸ©é™£æ±‚è§£
            for element, count in elements.items():
                side_elements[element] += count
        
        return side_elements
    
    def build_matrix(self, reactants, products):
        """å»ºç«‹ç·šæ€§æ–¹ç¨‹çµ„çš„çŸ©é™£"""
        elements_list = sorted(self.elements)
        matrix = []
        
        for element in elements_list:
            row = []
            # åæ‡‰ç‰©ä¿‚æ•¸ï¼ˆè² æ•¸ï¼‰
            for mol in reactants:
                row.append(-reactants[mol].get(element, 0))
            # ç”Ÿæˆç‰©ä¿‚æ•¸ï¼ˆæ­£æ•¸ï¼‰
            for mol in products:
                row.append(products[mol].get(element, 0))
            matrix.append(row)
        
        return np.array(matrix), elements_list
    
    def solve_coefficients(self, matrix):
        """æ±‚è§£ä¿‚æ•¸"""
        # æ·»åŠ ä¸€å€‹æ–¹ç¨‹ç¢ºä¿ä¿‚æ•¸ä¸å…¨ç‚º0ï¼ˆæœ€å°åŒ–ä¿‚æ•¸å’Œï¼‰
        extra_row = [1] * matrix.shape[1]
        matrix = np.vstack([matrix, extra_row])
        
        # å³é‚Šå‘é‡ï¼ˆå…¨0ï¼Œé™¤äº†æœ€å¾Œä¸€è¡Œæ˜¯1ï¼‰
        b = np.zeros(matrix.shape[0])
        b[-1] = 1
        
        try:
            # ä½¿ç”¨æœ€å°äºŒä¹˜æ³•æ±‚è§£
            coefficients = np.linalg.lstsq(matrix, b, rcond=None)[0]
            
            # è½‰æ›ç‚ºæœ€ç°¡æ•´æ•¸æ¯”
            coefficients = self.simplify_coefficients(coefficients)
            return coefficients
        except:
            return None
    
    def simplify_coefficients(self, coefficients):
        """å°‡ä¿‚æ•¸è½‰æ›ç‚ºæœ€ç°¡æ•´æ•¸æ¯”"""
        # æ‰¾åˆ°æœ€å°çš„æ­£æ•¸ä¿‚æ•¸
        min_coeff = min([c for c in coefficients if c > 0])
        
        # ç¸®æ”¾ä¿‚æ•¸
        coefficients = coefficients / min_coeff
        
        # å˜—è©¦è½‰æ›ç‚ºæ•´æ•¸
        for factor in range(1, 101):
            scaled = coefficients * factor
            if all(abs(round(x) - x) < 1e-6 for x in scaled):
                return [round(x) for x in scaled]
        
        return [round(x, 2) for x in coefficients]
    
    def balance_equation(self, equation):
        """å¹³è¡¡åŒ–å­¸æ–¹ç¨‹å¼çš„ä¸»å‡½æ•¸"""
        try:
            # åˆ†å‰²åæ‡‰ç‰©å’Œç”Ÿæˆç‰©
            if '->' in equation:
                reactant_side, product_side = equation.split('->')
            elif '=' in equation:
                reactant_side, product_side = equation.split('=')
            else:
                return "éŒ¯èª¤ï¼šè«‹ä½¿ç”¨ '->' æˆ– '=' åˆ†éš”åæ‡‰ç‰©å’Œç”Ÿæˆç‰©"
            
            # è§£æåæ‡‰ç‰©å’Œç”Ÿæˆç‰©
            reactant_molecules = [mol.strip() for mol in reactant_side.split('+')]
            product_molecules = [mol.strip() for mol in product_side.split('+')]
            
            # è§£ææ¯å€‹åˆ†å­
            reactants_dict = {}
            for mol in reactant_molecules:
                reactants_dict[mol] = self.parse_molecule(mol)
            
            products_dict = {}
            for mol in product_molecules:
                products_dict[mol] = self.parse_molecule(mol)
            
            # å»ºç«‹çŸ©é™£
            matrix, elements = self.build_matrix(reactants_dict, products_dict)
            
            # æ±‚è§£ä¿‚æ•¸
            coefficients = self.solve_coefficients(matrix)
            
            if coefficients is None:
                return "ç„¡æ³•å¹³è¡¡æ­¤æ–¹ç¨‹å¼"
            
            # æ§‹å»ºå¹³è¡¡å¾Œçš„æ–¹ç¨‹å¼
            balanced_reactants = []
            balanced_products = []
            
            for i, mol in enumerate(reactant_molecules):
                coeff = coefficients[i]
                if coeff != 1:
                    balanced_reactants.append(f"{coeff}{mol}")
                else:
                    balanced_reactants.append(mol)
            
            for i, mol in enumerate(product_molecules):
                coeff = coefficients[i + len(reactant_molecules)]
                if coeff != 1:
                    balanced_products.append(f"{coeff}{mol}")
                else:
                    balanced_products.append(mol)
            
            balanced_eq = " + ".join(balanced_reactants) + " -> " + " + ".join(balanced_products)
            return balanced_eq
            
        except Exception as e:
            return f"éŒ¯èª¤ï¼š{str(e)}"

# å‰µå»ºå¹³è¡¡å™¨å¯¦ä¾‹
balancer = ChemicalEquationBalancer()

# æ¸¬è©¦ç¯„ä¾‹
def test_balancer():
    test_equations = [
        "H2 + O2 -> H2O",
        "Fe + O2 -> Fe2O3", 
        "CH4 + O2 -> CO2 + H2O",
        "Al + HCl -> AlCl3 + H2",
        "Na + Cl2 -> NaCl"
    ]
    
    print("ğŸ§ª åŒ–å­¸æ–¹ç¨‹å¼å¹³è¡¡æ¸¬è©¦ ğŸ§ª\n")
    
    for equation in test_equations:
        print(f"åŸå§‹æ–¹ç¨‹å¼: {equation}")
        balanced = balancer.balance_equation(equation)
        print(f"å¹³è¡¡å¾Œ: {balanced}")
        print("-" * 50)

# åŸ·è¡Œæ¸¬è©¦
if __name__ == "__main__":
    test_balancer()
    
    # äº’å‹•å¼æ¸¬è©¦
    print("\nğŸ¯ äº’å‹•å¼å¹³è¡¡å™¨")
    print("è¼¸å…¥ 'quit' é€€å‡º")
    
    while True:
        user_input = input("\nè«‹è¼¸å…¥åŒ–å­¸æ–¹ç¨‹å¼: ")
        if user_input.lower() == 'quit':
            break
        result = balancer.balance_equation(user_input)
        print(f"çµæœ: {result}")